template <int D>
tarch::logging::Log tarch::multicore::dForRange<D>::_log( "tarch::multicore::dForRange" );


template <int D>
tarch::multicore::dForRange<D>::dForRange():
  _grainSize(-1),
  _interleaving(-1) {
}


template <int D>
tarch::multicore::dForRange<D>::dForRange(const dForRange<D>& range):
  _offset( range._offset),
  _range( range._range ),
  _grainSize( range._grainSize ),
  _interleaving( range._interleaving ) {
  logTraceInWith1Argument( "dForRange(dForRange)", range.toString() );
  assertion3( _grainSize>0, _offset, _range, _grainSize );
  logTraceOut( "dForRange(dForRange)" );
}


template <int D>
tarch::multicore::dForRange<D>::dForRange( const tarch::la::Vector<D,int>&  range, int grainSize, int interleaving ):
  _offset(0),
  _range(range),
  _grainSize(grainSize),
  _interleaving(interleaving) {
  logTraceInWith2Arguments( "dForRange(...)", range, grainSize );
  for (int d=0; d<D; d++) {
    assertion3( range(d)>=1, toString(), range, grainSize );
  }
  assertion3( interleaving>=1, toString(), range, grainSize );
  logTraceOut( "dForRange(...)" );
}


template <int D>
tarch::la::Vector<D,int> tarch::multicore::dForRange<D>::operator()(const tarch::la::Vector<D,int>& range) const {
  return _offset + _range * _interleaving;
}


template <int D>
std::vector< tarch::multicore::dForRange<D> >  tarch::multicore::dForRange<D>::getMinimalRanges() const {
  std::vector< dForRange<D> > result( tarch::la::volume(_range)/_grainSize+1);
  result.clear();
  result.push_back(*this);

  int i=0;
  while (i<static_cast<int>(result.size())) {
	while ( result[i].isDivisible() ) {
      result.push_back( result[i].split() );
	}
    i++;
  }

  return result;
}


template <int D>
tarch::multicore::dForRange<D>   tarch::multicore::dForRange<D>::split() {
  tarch::multicore::dForRange<D> result(*this);

  int splitAlongDimension = tarch::la::indexMax(_range);
  int oldRangeSizeAlongDimension = _range(splitAlongDimension);
  _range(splitAlongDimension) =  oldRangeSizeAlongDimension / 2;

  result._range(splitAlongDimension)  = oldRangeSizeAlongDimension - _range(splitAlongDimension);
  result._offset(splitAlongDimension) = result._offset(splitAlongDimension) + oldRangeSizeAlongDimension - result._range(splitAlongDimension);

  return result;
}


template <int D>
bool tarch::multicore::dForRange<D>::empty() const {
  logTraceIn( "empty()" );
  bool result = tarch::la::volume(_range)==0;
  assertion( !isDivisible() || !result );
  logTraceOutWith1Argument( "empty()", result );
  return result;
}


template <int D>
bool tarch::multicore::dForRange<D>::isDivisible() const {
  logTraceInWith1Argument( "isDivisible()", toString() );
  bool result = tarch::la::volume(_range) > _grainSize;
  logTraceOutWith1Argument( "isDivisible()", result );
  return result;
}


template <int D>
std::string tarch::multicore::dForRange<D>::toString() const {
  std::ostringstream msg;
  msg << "(range:" << _range << ",offset:" << _offset << ",grain-size:" << _grainSize << ")";
  return msg.str();
}


template <int D>
tarch::la::Vector<D,int> tarch::multicore::dForRange<D>::getOffset() const {
  return _offset;
}


template <int D>
tarch::la::Vector<D,int> tarch::multicore::dForRange<D>::getRange() const {
  return _range;
}
